<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Atari 8-Track ProTracker Mixer</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=IBM+Plex+Mono:wght@400;500;700&display=swap');
    :root {
      --bg: #101218;
      --panel: #171c27;
      --line: #38445a;
      --ink: #eaf1ff;
      --muted: #9aa9c7;
      --accent: #5bf5c9;
      --accent2: #ffd967;
      --danger: #ff8484;
      --ok: #7af58a;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      color: var(--ink);
      font-family: "IBM Plex Mono", monospace;
      background:
        radial-gradient(900px 380px at 10% -8%, rgba(91,245,201,.16), transparent 60%),
        radial-gradient(900px 380px at 98% -18%, rgba(255,217,103,.12), transparent 60%),
        linear-gradient(180deg, #0c0f14 0%, #121822 100%);
      min-height: 100vh;
    }
    .scan {
      position: fixed;
      inset: 0;
      pointer-events: none;
      background: repeating-linear-gradient(to bottom, rgba(255,255,255,.025) 0, rgba(255,255,255,.025) 1px, transparent 3px, transparent 5px);
      opacity: .22;
      mix-blend-mode: soft-light;
    }
    main { max-width: 1180px; margin: 0 auto; padding: 1.1rem .9rem 1.8rem; }
    .frame {
      border: 1px solid var(--line);
      border-radius: 14px;
      background: linear-gradient(180deg, rgba(23,28,39,.95), rgba(17,22,30,.96));
      box-shadow: 0 18px 40px rgba(0,0,0,.34), inset 0 1px 0 rgba(255,255,255,.04);
      overflow: hidden;
    }
    .head {
      padding: .95rem;
      border-bottom: 1px solid var(--line);
      background: linear-gradient(90deg, rgba(91,245,201,.10), rgba(255,217,103,.10));
    }
    h1 {
      margin: 0;
      font-family: "Press Start 2P", monospace;
      line-height: 1.6;
      font-size: clamp(.73rem, 1.7vw, 1rem);
      color: var(--accent);
      text-shadow: 0 0 10px rgba(91,245,201,.3);
    }
    .sub { margin-top: .5rem; font-size: .85rem; color: var(--muted); }

    .layout { display: grid; grid-template-columns: 330px 1fr; gap: .9rem; padding: .9rem; }
    .panel {
      border: 1px solid var(--line);
      border-radius: 11px;
      padding: .78rem;
      background: #131924;
    }
    .label { display:block; margin-bottom:.35rem; color:#b9c8e5; font-size:.8rem; }
    input[type="number"] {
      width: 100%;
      border: 1px solid #46526a;
      border-radius: 9px;
      background: #0d121a;
      color: var(--ink);
      padding: .56rem .62rem;
      font: inherit;
    }
    input[type="file"] {
      width: 100%;
      border: 1px dashed #5c6c89;
      border-radius: 9px;
      background: #0d121a;
      color: var(--ink);
      padding: .62rem;
      font: inherit;
    }
    .stack { display: grid; gap: .55rem; }
    .btns { display:flex; gap:.45rem; flex-wrap:wrap; margin-top:.35rem; }
    button, .btn {
      border: 1px solid var(--line);
      border-radius: 9px;
      padding: .5rem .7rem;
      font: inherit;
      font-weight: 700;
      cursor: pointer;
      color: var(--ink);
      background: #1f2735;
      text-decoration: none;
    }
    button.primary { background: linear-gradient(180deg, #5bf5c9, #33dcae); color: #032116; border-color: #6ef5ce; }
    button.warn { background: linear-gradient(180deg, #ffe083, #ffc942); color: #231c07; border-color: #ffe08a; }
    button:disabled { opacity: .55; cursor: not-allowed; }
    .status { margin-top: .55rem; min-height: 1.3rem; font-size: .83rem; color: var(--muted); }
    .status.error { color: var(--danger); }
    .status.ok { color: var(--ok); }
    .readout { display:grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap:.45rem; margin-top:.45rem; }
    .cell { border: 1px solid var(--line); border-radius: 8px; background:#0d131b; padding:.48rem; }
    .cell b { display:block; font-size:.69rem; color:var(--accent2); margin-bottom:.16rem; }
    .cell span { font-size:.88rem; font-weight:700; }

    .mixer { border: 1px solid var(--line); border-radius: 11px; background: #111722; padding: .65rem; }
    .transport { display:flex; flex-wrap:wrap; gap:.45rem; align-items:center; margin-bottom:.6rem; }
    .transport .time { margin-left: auto; color: #b8c7e4; font-size: .83rem; }
    .channels {
      display: grid;
      grid-template-columns: repeat(8, minmax(88px, 1fr));
      gap: .45rem;
    }
    .ch {
      border: 1px solid var(--line);
      border-radius: 9px;
      padding: .46rem;
      background: linear-gradient(180deg, #161d2a, #101620);
      display: grid;
      gap: .34rem;
      justify-items: center;
    }
    .name { font-size: .72rem; color: #c2d0eb; letter-spacing: .02em; }
    .vu {
      width: 100%;
      height: 112px;
      border: 1px solid #3f4c62;
      border-radius: 7px;
      background: #090d13;
      position: relative;
      overflow: hidden;
    }
    .vu-fill {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      height: 0%;
      background: linear-gradient(0deg, #30db9d 0%, #a9eb5f 62%, #ffd651 100%);
      transition: height .06s linear;
    }
    .db { font-size: .67rem; color: #96a8c8; }
    input[type="range"].fader {
      width: 100%;
      writing-mode: bt-lr;
      -webkit-appearance: slider-vertical;
      appearance: slider-vertical;
      height: 132px;
      background: transparent;
    }
    .value { font-size: .7rem; color: #d7e4ff; }
    .note { margin-top: .6rem; font-size: .78rem; color: var(--muted); line-height: 1.5; }

    @media (max-width: 980px) {
      .layout { grid-template-columns: 1fr; }
      .channels { grid-template-columns: repeat(4, minmax(88px, 1fr)); }
    }
    @media (max-width: 560px) {
      .channels { grid-template-columns: repeat(2, minmax(88px, 1fr)); }
    }
  </style>
</head>
<body>
  <div class="scan"></div>
  <main>
    <section class="frame">
      <div class="head">
        <h1>ATARI PROTRACKER STYLE 8-TRACK MIXER</h1>
        <div class="sub">Upload a WAV file. The remix follows source length, estimated key, section energy, and tempo movement for timeline sync.</div>
      </div>

      <div class="layout">
        <section class="panel">
          <div class="stack">
            <div>
              <label class="label" for="source-wav">Source WAV File</label>
              <input id="source-wav" type="file" accept=".wav,audio/wav">
            </div>
            <div>
              <label class="label" for="master-gain">Master</label>
              <input id="master-gain" type="number" min="0" max="2" step="0.05" value="1.00">
            </div>
            <div class="btns">
              <button id="build" class="primary" type="button">Build Session</button>
              <button id="download" class="warn" type="button" disabled>Export ZIP</button>
              <a class="btn" href="/" target="_blank" rel="noopener">Home</a>
            </div>
            <div id="status" class="status">Ready.</div>

            <div class="readout">
              <div class="cell"><b>Source</b><span id="meta-source">-</span></div>
              <div class="cell"><b>Avg BPM</b><span id="meta-bpm">-</span></div>
              <div class="cell"><b>Duration</b><span id="meta-duration">-</span></div>
              <div class="cell"><b>Estimated Key</b><span id="meta-key">-</span></div>
            </div>
          </div>
        </section>

        <section class="mixer">
          <div class="transport">
            <button id="play" type="button" disabled>Play</button>
            <button id="stop" type="button" disabled>Stop</button>
            <button id="reset" type="button" disabled>Reset Faders</button>
            <span class="time" id="time-readout">00:00 / 00:00</span>
          </div>

          <div class="channels" id="channels"></div>
          <div class="note">
            Tip: drag the original WAV into your DAW and align start time with this remix. They are rendered to the source timeline length.
          </div>
        </section>
      </div>
    </section>
  </main>

  <script>
    const TRACKS = ["kick", "snare", "hat", "bass", "arp", "chord", "lead", "fx"];
    const state = {
      sessionId: null,
      context: null,
      masterGain: null,
      buffers: new Map(),
      gainNodes: new Map(),
      analyserNodes: new Map(),
      sources: [],
      startedAt: 0,
      offset: 0,
      isPlaying: false,
      duration: 0,
      raf: 0,
    };

    const el = {
      sourceWav: document.getElementById("source-wav"),
      masterGain: document.getElementById("master-gain"),
      build: document.getElementById("build"),
      download: document.getElementById("download"),
      play: document.getElementById("play"),
      stop: document.getElementById("stop"),
      reset: document.getElementById("reset"),
      status: document.getElementById("status"),
      timeReadout: document.getElementById("time-readout"),
      channels: document.getElementById("channels"),
      metaSource: document.getElementById("meta-source"),
      metaBpm: document.getElementById("meta-bpm"),
      metaDuration: document.getElementById("meta-duration"),
      metaKey: document.getElementById("meta-key"),
    };

    const vuElements = new Map();

    function setStatus(message, mode = "") {
      el.status.textContent = message;
      el.status.classList.toggle("error", mode === "error");
      el.status.classList.toggle("ok", mode === "ok");
    }

    function fmtTime(seconds) {
      const s = Math.max(0, Math.floor(seconds || 0));
      const m = Math.floor(s / 60);
      const rem = s % 60;
      return `${String(m).padStart(2, "0")}:${String(rem).padStart(2, "0")}`;
    }

    async function looksLikeWav(file) {
      const buf = await file.slice(0, 12).arrayBuffer();
      const sig = new Uint8Array(buf);
      const ascii = (arr) => String.fromCharCode(...arr);
      if (sig.length < 12) return false;
      return ascii(sig.slice(0, 4)) === "RIFF" && ascii(sig.slice(8, 12)) === "WAVE";
    }

    function currentTimePosition() {
      if (!state.isPlaying || !state.context) return state.offset;
      return Math.min(state.duration, state.offset + (state.context.currentTime - state.startedAt));
    }

    function updateTimeReadout() {
      el.timeReadout.textContent = `${fmtTime(currentTimePosition())} / ${fmtTime(state.duration)}`;
    }

    function buildChannelUi() {
      el.channels.innerHTML = "";
      TRACKS.forEach((track) => {
        const box = document.createElement("div");
        box.className = "ch";
        box.innerHTML = `
          <div class="name">${track.toUpperCase()}</div>
          <div class="vu"><div class="vu-fill" data-track="${track}"></div></div>
          <div class="db" data-db="${track}">-inf dB</div>
          <input class="fader" data-fader="${track}" type="range" min="0" max="1.4" step="0.01" value="1.00">
          <div class="value" data-value="${track}">1.00</div>
        `;
        el.channels.appendChild(box);

        const fader = box.querySelector(`[data-fader="${track}"]`);
        const valueEl = box.querySelector(`[data-value="${track}"]`);
        const vuFill = box.querySelector(`[data-track="${track}"]`);
        const dbEl = box.querySelector(`[data-db="${track}"]`);
        vuElements.set(track, { vuFill, dbEl });

        fader.addEventListener("input", () => {
          const val = Number.parseFloat(fader.value);
          valueEl.textContent = val.toFixed(2);
          const gain = state.gainNodes.get(track);
          if (gain) gain.gain.value = val;
        });
      });
    }

    async function ensureAudioContext() {
      if (state.context) return state.context;
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      state.context = new AudioCtx();
      state.masterGain = state.context.createGain();
      state.masterGain.gain.value = Number.parseFloat(el.masterGain.value || "1") || 1;
      state.masterGain.connect(state.context.destination);
      return state.context;
    }

    function stopPlayback(resetOffset = false) {
      state.sources.forEach((src) => {
        try { src.stop(); } catch (_) {}
      });
      state.sources = [];
      state.isPlaying = false;
      if (resetOffset) state.offset = 0;
      if (state.raf) cancelAnimationFrame(state.raf);
      updateTimeReadout();
    }

    function renderMeters() {
      if (!state.isPlaying) return;
      TRACKS.forEach((track) => {
        const analyser = state.analyserNodes.get(track);
        const ui = vuElements.get(track);
        if (!analyser || !ui) return;

        const arr = new Uint8Array(analyser.fftSize);
        analyser.getByteTimeDomainData(arr);

        let peak = 0;
        for (let i = 0; i < arr.length; i += 1) {
          const v = (arr[i] - 128) / 128;
          const a = Math.abs(v);
          if (a > peak) peak = a;
        }

        const normalized = Math.min(1, peak * 1.8);
        ui.vuFill.style.height = `${Math.round(normalized * 100)}%`;
        const db = peak > 0.00001 ? (20 * Math.log10(peak)).toFixed(1) : "-inf";
        ui.dbEl.textContent = `${db} dB`;
      });

      updateTimeReadout();
      if (currentTimePosition() >= state.duration) {
        stopPlayback(true);
        return;
      }
      state.raf = requestAnimationFrame(renderMeters);
    }

    async function decodeStem(url) {
      const res = await fetch(url);
      if (!res.ok) throw new Error("Failed to load stem");
      const buf = await res.arrayBuffer();
      return state.context.decodeAudioData(buf.slice(0));
    }

    async function loadSessionStems(stemUrls) {
      state.buffers.clear();
      state.gainNodes.clear();
      state.analyserNodes.clear();

      for (const track of TRACKS) {
        const gain = state.context.createGain();
        gain.gain.value = 1;
        const analyser = state.context.createAnalyser();
        analyser.fftSize = 512;
        analyser.smoothingTimeConstant = 0.74;

        gain.connect(analyser);
        analyser.connect(state.masterGain);

        state.gainNodes.set(track, gain);
        state.analyserNodes.set(track, analyser);
      }

      await Promise.all(TRACKS.map(async (track) => {
        const buffer = await decodeStem(stemUrls[track]);
        state.buffers.set(track, buffer);
      }));

      state.duration = state.buffers.get(TRACKS[0])?.duration || 0;
      state.offset = 0;
      updateTimeReadout();
    }

    function startPlayback() {
      if (state.isPlaying || !state.context) return;
      const offset = Math.min(state.offset, Math.max(0, state.duration - 0.05));
      state.sources = [];

      TRACKS.forEach((track) => {
        const buffer = state.buffers.get(track);
        const gain = state.gainNodes.get(track);
        if (!buffer || !gain) return;
        const src = state.context.createBufferSource();
        src.buffer = buffer;
        src.connect(gain);
        src.start(0, offset);
        state.sources.push(src);
      });

      state.startedAt = state.context.currentTime;
      state.isPlaying = true;
      renderMeters();
    }

    function pausePlayback() {
      if (!state.isPlaying || !state.context) return;
      state.offset = currentTimePosition();
      stopPlayback(false);
    }

    async function waitForJob(jobId) {
      const maxPolls = 240;
      for (let i = 0; i < maxPolls; i += 1) {
        const res = await fetch(`/api/atari/job/${jobId}`);
        const data = await res.json().catch(() => ({}));
        if (!res.ok) {
          throw new Error(data.error || `Build job failed (${res.status})`);
        }
        if (data.status === "ready") {
          return data;
        }
        if (data.status === "failed") {
          throw new Error(data.error || "Build failed");
        }
        setStatus(`Building session... ${Math.min(99, Math.floor((i / maxPolls) * 100))}%`);
        await new Promise((r) => setTimeout(r, 1000));
      }
      throw new Error("Build timed out. Try a shorter PCM WAV file.");
    }

    async function buildSession() {
      const file = el.sourceWav.files?.[0];
      if (!file) {
        setStatus("Choose a WAV file first.", "error");
        return;
      }

      if (!file.name.toLowerCase().endsWith(".wav")) {
        setStatus("Only WAV files are supported.", "error");
        return;
      }
      if (!(await looksLikeWav(file))) {
        setStatus("This file is not a true WAV (RIFF/WAVE). Convert the source to PCM WAV first.", "error");
        return;
      }

      el.build.disabled = true;
      el.download.disabled = true;
      el.play.disabled = true;
      el.stop.disabled = true;
      el.reset.disabled = true;
      setStatus("Analyzing WAV and building synced Atari session...");

      try {
        await ensureAudioContext();
        pausePlayback();

        const form = new FormData();
        form.append("source_wav", file, file.name);

        const res = await fetch("/api/atari/session", {
          method: "POST",
          body: form,
        });
        let data = {};
        try {
          data = await res.json();
        } catch (_) {
          if (!res.ok) {
            throw new Error(`Session build failed (${res.status}). Try a shorter PCM WAV file.`);
          }
        }
        if (!res.ok && res.status !== 202) throw new Error(data.error || "Session build failed");
        if (!data.job_id) throw new Error("Build job was not created");

        data = await waitForJob(data.job_id);

        state.sessionId = data.session_id;
        await loadSessionStems(data.stem_urls);

        el.metaSource.textContent = data.source_name || "uploaded.wav";
        el.metaBpm.textContent = String(data.bpm);
        el.metaDuration.textContent = `${data.duration_seconds}s`;
        el.metaKey.textContent = data.estimated_key || "-";

        el.download.disabled = false;
        el.play.disabled = false;
        el.stop.disabled = false;
        el.reset.disabled = false;

        setStatus(`Session ready (${data.duration_seconds}s, ${data.bpm} BPM, ${data.estimated_key}).`, "ok");
      } catch (err) {
        setStatus(err.message || "Session build failed.", "error");
      } finally {
        el.build.disabled = false;
      }
    }

    async function downloadSessionZip() {
      if (!state.sessionId) {
        setStatus("Build a session first.", "error");
        return;
      }
      try {
        setStatus("Preparing ZIP export...");
        const res = await fetch(`/api/atari/session/${state.sessionId}/export`, { method: "POST" });
        if (!res.ok) {
          const data = await res.json().catch(() => ({}));
          throw new Error(data.error || "Export failed");
        }
        const blob = await res.blob();
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        const cd = res.headers.get("Content-Disposition") || "";
        const m = cd.match(/filename="([^"]+)"/);
        a.download = m ? m[1] : "atari-stems.zip";
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
        setStatus("ZIP export downloaded.", "ok");
      } catch (err) {
        setStatus(err.message || "Export failed.", "error");
      }
    }

    el.masterGain.addEventListener("input", () => {
      const val = Number.parseFloat(el.masterGain.value || "1") || 1;
      if (state.masterGain) state.masterGain.gain.value = val;
    });

    el.build.addEventListener("click", buildSession);
    el.download.addEventListener("click", downloadSessionZip);

    el.play.addEventListener("click", async () => {
      if (!state.sessionId) {
        setStatus("Build a session first.", "error");
        return;
      }
      await ensureAudioContext();
      if (state.context.state === "suspended") await state.context.resume();
      if (state.isPlaying) {
        pausePlayback();
        setStatus("Paused.");
      } else {
        startPlayback();
        setStatus("Playing.", "ok");
      }
    });

    el.stop.addEventListener("click", () => {
      pausePlayback();
      state.offset = 0;
      updateTimeReadout();
      setStatus("Stopped.");
    });

    el.reset.addEventListener("click", () => {
      TRACKS.forEach((track) => {
        const slider = document.querySelector(`[data-fader="${track}"]`);
        const valueEl = document.querySelector(`[data-value="${track}"]`);
        if (slider) slider.value = "1.00";
        if (valueEl) valueEl.textContent = "1.00";
        const gain = state.gainNodes.get(track);
        if (gain) gain.gain.value = 1;
      });
      setStatus("Faders reset.");
    });

    buildChannelUi();
    updateTimeReadout();
  </script>
</body>
</html>
